/*
 * SPDX-FileCopyrightText: 2021-2024 The Refinery Authors <https://refinery.tools/>
 *
 * SPDX-License-Identifier: EPL-2.0
 */

/*
 * generated by Xtext 2.29.0.M2
 */
package tools.refinery.language.parser.antlr;

import com.google.inject.Inject;
import org.antlr.runtime.Token;
import org.antlr.runtime.TokenSource;
import tools.refinery.language.parser.antlr.internal.InternalProblemParser;

import java.util.ArrayDeque;
import java.util.Deque;

public class ProblemTokenSource implements TokenSource {
	private IdentifierTokenProvider identifierTokenProvider;

	private final TokenSource delegate;

	private final Deque<Token> buffer = new ArrayDeque<>();

	private boolean recursive;

	private boolean seenId;

	private boolean lastVisible;

	public ProblemTokenSource(TokenSource delegate) {
		this.delegate = delegate;
	}

	@Inject
	public void setIdentifierTokenProvider(IdentifierTokenProvider identifierTokenProvider) {
		this.identifierTokenProvider = identifierTokenProvider;
	}

	public boolean isRecursive() {
		return recursive;
	}

	public void setRecursive(boolean recursive) {
		this.recursive = recursive;
	}

	@Override
	public Token nextToken() {
		boolean fromStream = buffer.isEmpty();
		var token = fromStream ? delegate.nextToken() : buffer.removeFirst();
		if (seenId) {
			if (fromStream && isPlusOrTransitiveClosure(token) && peekForTransitiveClosure()) {
				token.setType(InternalProblemParser.RULE_TRANSITIVE_CLOSURE);
			} else if (lastVisible && isQualifiedNameSeparator(token)) {
				token.setType(InternalProblemParser.RULE_QUALIFIED_NAME_SEPARATOR);
			}
		}
		lastVisible = isVisibleToken(token);
		if (lastVisible) {
			seenId = isIdentifier(token);
		}
		return token;
	}

	@Override
	public String getSourceName() {
		return "[%s]%s".formatted(this.getClass().getSimpleName(), delegate.getSourceName());
	}

	protected boolean isIdentifier(Token token) {
		return identifierTokenProvider.isIdentifierToken(token.getType());
	}

	protected boolean isPlusOrTransitiveClosure(Token token) {
		return token.getType() == InternalProblemParser.PlusSign;
	}

	protected boolean isQualifiedNameSeparator(Token token) {
		return token.getType() == InternalProblemParser.ColonColon;
	}

	protected boolean isVisibleToken(Token token) {
		int tokenId = token.getType();
		return tokenId != InternalProblemParser.RULE_WS && tokenId != InternalProblemParser.RULE_SL_COMMENT &&
				tokenId != InternalProblemParser.RULE_ML_COMMENT;
	}

	protected boolean peekForTransitiveClosure() {
		Token token = peekWithSkipWhitespace();
		if (token.getType() != InternalProblemParser.LeftParenthesis) {
			return false;
		}
		boolean allowFullyQualifiedName = true;
		while (true) {
			token = peekWithSkipWhitespace();
			if (allowFullyQualifiedName && token.getType() == InternalProblemParser.ColonColon) {
				token = peekWithSkipWhitespace();
			}
			if (!isIdentifier(token)) {
				return false;
			}
			allowFullyQualifiedName = false;
			token = peekWithSkipWhitespace();
			switch (token.getType()) {
			case InternalProblemParser.Comma:
				return true;
			case InternalProblemParser.ColonColon:
				break;
			default:
				// By default, we do not peek at inner plus signs to limit recursion depth.
				// Such expressions are never valid, so we don't have to parse them correctly.
				if (recursive && isPlusOrTransitiveClosure(token) && peekForTransitiveClosure()) {
					token.setType(InternalProblemParser.RULE_TRANSITIVE_CLOSURE);
				}
				// Not a transitive closure for the initial position where we started peeking.
				return false;
			}
		}
	}

	protected Token peekToken() {
		var token = delegate.nextToken();
		buffer.addLast(token);
		return token;
	}

	protected Token peekWithSkipWhitespace() {
		Token token;
		do {
			token = peekToken();
		} while (token != null && !isVisibleToken(token));
		return token;
	}
}
